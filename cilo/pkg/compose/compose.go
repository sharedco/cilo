package compose

import (
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"github.com/sharedco/cilo/pkg/config"
	"github.com/sharedco/cilo/pkg/models"
	"gopkg.in/yaml.v3"
)

// Transform creates a cilo override compose file for the given base compose files.
func Transform(env *models.Environment, baseFiles []string, overridePath, dnsSuffix string) error {
	services, err := LoadServices(baseFiles)
	if err != nil {
		return err
	}
	if len(services) == 0 {
		return fmt.Errorf("no services found in compose files")
	}
	if dnsSuffix == "" {
		dnsSuffix = ".test"
	}

	// Parse subnet to get base IP
	_, ipnet, err := net.ParseCIDR(env.Subnet)
	if err != nil {
		return fmt.Errorf("invalid subnet: %w", err)
	}

	// Get the first IP in the subnet
	baseIP := ipnet.IP
	// Increment to skip network address and start from .2
	ip := incrementIP(baseIP)
	ip = incrementIP(ip) // Start from .2

	networkName := "default"

	// First pass: find the default ingress service
	// Priority: 1) cilo.ingress label, 2) default service names, 3) first service with hostnames
	ingressName := ""
	servicesWithHostnames := []string{}

	for name, service := range services {
		if service.Labels != nil {
			if _, ok := service.Labels["cilo.hostnames"]; ok {
				servicesWithHostnames = append(servicesWithHostnames, name)
			}
			if ingressLabel, ok := service.Labels["cilo.ingress"]; ok && ingressLabel == "true" {
				ingressName = name
			}
		}
		if ingressName == "" && (name == "nginx" || name == "web" || name == "app" || name == "frontend") {
			ingressName = name
		}
	}
	if ingressName == "" && len(servicesWithHostnames) > 0 {
		ingressName = servicesWithHostnames[0]
	}

	override := map[string]interface{}{
		"services": map[string]interface{}{},
		"networks": map[string]interface{}{
			networkName: map[string]interface{}{
				"driver": "bridge",
				"ipam": map[string]interface{}{
					"config": []map[string]string{{"subnet": env.Subnet}},
				},
			},
		},
	}

	serviceOverrides := override["services"].(map[string]interface{})
	for _, name := range SortedServiceNames(services) {
		service := services[name]
		containerName := fmt.Sprintf("cilo_%s_%s", env.Name, name)
		serviceOverrides[name] = map[string]interface{}{
			"ports":          []interface{}{},
			"container_name": containerName,
			"networks": map[string]interface{}{
				networkName: map[string]interface{}{
					"ipv4_address": ip.String(),
				},
			},
		}

		hostnames := []string{}
		if service.Labels != nil {
			if hostnamesLabel, ok := service.Labels["cilo.hostnames"]; ok {
				hostnames = strings.Split(hostnamesLabel, ",")
				for i, h := range hostnames {
					hostnames[i] = strings.TrimSpace(h)
				}
			}
		}

		isIngress := (name == ingressName) || len(hostnames) > 0
		env.Services[name] = &models.Service{
			Name:      name,
			IP:        ip.String(),
			Container: containerName,
			URL:       fmt.Sprintf("http://%s.%s%s", name, env.Name, dnsSuffix),
			IsIngress: isIngress,
			Hostnames: hostnames,
		}

		ip = incrementIP(ip)
	}

	output, err := yaml.Marshal(&override)
	if err != nil {
		return fmt.Errorf("failed to marshal override file: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(overridePath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	header := "# Auto-generated by cilo. Do not edit directly.\n"
	header += "# This file overrides your base docker-compose.yml files.\n\n"

	if err := os.WriteFile(overridePath, []byte(header+string(output)), 0644); err != nil {
		return fmt.Errorf("failed to write override file: %w", err)
	}

	return nil
}

// CreateMinimal creates a minimal docker-compose.yml for scratch environments
func CreateMinimal(env *models.Environment, outputPath string) error {
	compose := models.ComposeFile{
		Services: map[string]*models.ComposeService{
			"web": {
				Image: "nginx:alpine",
			},
		},
	}

	output, err := yaml.Marshal(&compose)
	if err != nil {
		return fmt.Errorf("failed to marshal compose file: %w", err)
	}

	if err := os.WriteFile(outputPath, output, 0644); err != nil {
		return fmt.Errorf("failed to write compose file: %w", err)
	}

	return nil
}

// GetServiceNames extracts service names from compose files
func GetServiceNames(paths []string) ([]string, error) {
	services, err := LoadServices(paths)
	if err != nil {
		return nil, err
	}
	return SortedServiceNames(services), nil
}

func incrementIP(ip net.IP) net.IP {
	newIP := make(net.IP, len(ip))
	copy(newIP, ip)

	for i := len(newIP) - 1; i >= 0; i-- {
		newIP[i]++
		if newIP[i] > 0 {
			break
		}
	}

	return newIP
}

// Validate validates compose files by ensuring a services section exists
func Validate(paths []string) error {
	services, err := LoadServices(paths)
	if err != nil {
		return err
	}
	if len(services) == 0 {
		return fmt.Errorf("compose files have no services")
	}
	return nil
}

// SyncServices updates environment services from running containers
func SyncServices(env *models.Environment) error {
	workspace := config.GetEnvPath(env.Project, env.Name)
	projectConfig, _ := models.LoadProjectConfigFromPath(workspace)
	composeFiles, _, err := ResolveComposeFiles(workspace, nil)
	if err == nil && projectConfig != nil {
		composeFiles, _, err = ResolveComposeFiles(workspace, projectConfig.ComposeFiles)
	}
	if err != nil {
		return err
	}

	names, err := GetServiceNames(composeFiles)
	if err != nil {
		return err
	}

	// Update URLs for all services
	for _, name := range names {
		if service, exists := env.Services[name]; exists {
			suffix := env.DNSSuffix
			if suffix == "" {
				suffix = ".test"
			}
			service.URL = fmt.Sprintf("http://%s.%s%s", name, env.Name, suffix)
		}
	}

	return nil
}
