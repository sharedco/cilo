// Copyright (c) 2026 Cilo Authors
// SPDX-License-Identifier: MIT
// See LICENSES/MIT.txt for full license text

package compose

import (
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"

	"github.com/sharedco/cilo/internal/config"
	"github.com/sharedco/cilo/internal/models"
	"gopkg.in/yaml.v3"
)

// Transform creates a cilo override compose file for the given base compose files.
func Transform(env *models.Environment, baseFiles []string, overridePath, dnsSuffix string) error {
	return TransformWithShared(env, baseFiles, overridePath, dnsSuffix, nil)
}

// TransformWithShared creates a cilo override compose file, skipping shared services
func TransformWithShared(env *models.Environment, baseFiles []string, overridePath, dnsSuffix string, sharedServices []string) error {
	services, err := LoadServices(baseFiles)
	if err != nil {
		return err
	}
	if len(services) == 0 {
		return fmt.Errorf("no services found in compose files")
	}
	if dnsSuffix == "" {
		dnsSuffix = ".test"
	}

	// Parse subnet to get base IP
	_, ipnet, err := net.ParseCIDR(env.Subnet)
	if err != nil {
		return fmt.Errorf("invalid subnet: %w", err)
	}

	// Get the first IP in the subnet
	baseIP := ipnet.IP
	// Skip network address (.1) and reserve .2-.9 for shared services
	// Start isolated services from .10
	ip := baseIP
	for i := 0; i < 10; i++ {
		ip = incrementIP(ip)
	}

	networkName := "default"

	// First pass: find the default ingress service
	// Priority: 1) cilo.ingress label, 2) default service names, 3) first service with hostnames
	ingressName := ""
	servicesWithHostnames := []string{}

	for name, service := range services {
		// Skip shared services in ingress detection
		if contains(sharedServices, name) {
			continue
		}

		if service.Labels != nil {
			if _, ok := service.Labels["cilo.hostnames"]; ok {
				servicesWithHostnames = append(servicesWithHostnames, name)
			}
			if ingressLabel, ok := service.Labels["cilo.ingress"]; ok && ingressLabel == "true" {
				ingressName = name
			}
		}
		if ingressName == "" && (name == "nginx" || name == "web" || name == "app" || name == "frontend") {
			ingressName = name
		}
	}
	if ingressName == "" && len(servicesWithHostnames) > 0 {
		ingressName = servicesWithHostnames[0]
	}

	override := map[string]interface{}{
		"services": map[string]interface{}{},
		"networks": map[string]interface{}{
			networkName: map[string]interface{}{
				"name":     fmt.Sprintf("cilo_%s", env.Name),
				"external": true,
			},
		},
	}

	// Initialize services map if nil
	if env.Services == nil {
		env.Services = make(map[string]*models.Service)
	}

	serviceOverrides := override["services"].(map[string]interface{})
	for _, name := range SortedServiceNames(services) {
		// For shared services, mark them as disabled so compose doesn't start them
		if contains(sharedServices, name) {
			serviceOverrides[name] = map[string]interface{}{
				"deploy": map[string]interface{}{
					"replicas": 0,
				},
			}
			continue
		}

		service := services[name]
		containerName := fmt.Sprintf("cilo_%s_%s", env.Name, name)
		serviceOverrides[name] = map[string]interface{}{
			"ports":          []interface{}{},
			"container_name": containerName,
			"networks": map[string]interface{}{
				networkName: map[string]interface{}{
					"ipv4_address": ip.String(),
				},
			},
		}

		hostnames := []string{}
		if service.Labels != nil {
			if hostnamesLabel, ok := service.Labels["cilo.hostnames"]; ok {
				hostnames = strings.Split(hostnamesLabel, ",")
				for i, h := range hostnames {
					hostnames[i] = strings.TrimSpace(h)
				}
			}
		}

		isIngress := (name == ingressName) || len(hostnames) > 0
		env.Services[name] = &models.Service{
			Name:      name,
			IP:        ip.String(),
			Container: containerName,
			URL:       fmt.Sprintf("http://%s.%s%s", name, env.Name, dnsSuffix),
			IsIngress: isIngress,
			Hostnames: hostnames,
		}

		ip = incrementIP(ip)
	}

	output, err := yaml.Marshal(&override)
	if err != nil {
		return fmt.Errorf("failed to marshal override file: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(overridePath), 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	header := "# Auto-generated by cilo. Do not edit directly.\n"
	header += "# This file overrides your base docker-compose.yml files.\n\n"

	if err := os.WriteFile(overridePath, []byte(header+string(output)), 0644); err != nil {
		return fmt.Errorf("failed to write override file: %w", err)
	}

	return nil
}

// contains checks if a slice contains a value
func contains(slice []string, value string) bool {
	for _, item := range slice {
		if item == value {
			return true
		}
	}
	return false
}

// CreateMinimal creates a minimal docker-compose.yml for scratch environments
func CreateMinimal(env *models.Environment, outputPath string) error {
	compose := models.ComposeFile{
		Services: map[string]*models.ComposeService{
			"web": {
				Image: "nginx:alpine",
			},
		},
	}

	output, err := yaml.Marshal(&compose)
	if err != nil {
		return fmt.Errorf("failed to marshal compose file: %w", err)
	}

	if err := os.WriteFile(outputPath, output, 0644); err != nil {
		return fmt.Errorf("failed to write compose file: %w", err)
	}

	return nil
}

// GetServiceNames extracts service names from compose files
func GetServiceNames(paths []string) ([]string, error) {
	services, err := LoadServices(paths)
	if err != nil {
		return nil, err
	}
	return SortedServiceNames(services), nil
}

func incrementIP(ip net.IP) net.IP {
	newIP := make(net.IP, len(ip))
	copy(newIP, ip)

	for i := len(newIP) - 1; i >= 0; i-- {
		newIP[i]++
		if newIP[i] > 0 {
			break
		}
	}

	return newIP
}

// Validate validates compose files by ensuring a services section exists
func Validate(paths []string) error {
	services, err := LoadServices(paths)
	if err != nil {
		return err
	}
	if len(services) == 0 {
		return fmt.Errorf("compose files have no services")
	}
	return nil
}

// SyncServices updates environment services from running containers
func SyncServices(env *models.Environment) error {
	workspace := config.GetEnvPath(env.Project, env.Name)
	projectConfig, _ := models.LoadProjectConfigFromPath(workspace)
	composeFiles, _, err := ResolveComposeFiles(workspace, nil)
	if err == nil && projectConfig != nil {
		composeFiles, _, err = ResolveComposeFiles(workspace, projectConfig.ComposeFiles)
	}
	if err != nil {
		return err
	}

	names, err := GetServiceNames(composeFiles)
	if err != nil {
		return err
	}

	// Update URLs for all services
	for _, name := range names {
		if service, exists := env.Services[name]; exists {
			suffix := env.DNSSuffix
			if suffix == "" {
				suffix = ".test"
			}
			service.URL = fmt.Sprintf("http://%s.%s%s", name, env.Name, suffix)
		}
	}

	return nil
}
