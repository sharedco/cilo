// Copyright (c) 2026 Cilo Authors
// SPDX-License-Identifier: MIT
// See LICENSES/MIT.txt for full license text

package dns

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/sharedco/cilo/internal/cilod"
)

func TestAddRemoteDNSEntries(t *testing.T) {
	dnsDir := t.TempDir()
	origGetDNSDir := getDNSDir
	getDNSDir = func() string { return dnsDir }
	defer func() { getDNSDir = origGetDNSDir }()

	initialConfig := `# Auto-generated by cilo
port=5354
bind-interfaces
listen-address=127.0.0.1

# Environment: local-env
address=/api.local-env.test/10.224.1.2
address=/db.local-env.test/10.224.1.3

`
	configPath := filepath.Join(dnsDir, "dnsmasq.conf")
	if err := os.WriteFile(configPath, []byte(initialConfig), 0644); err != nil {
		t.Fatalf("Failed to write initial config: %v", err)
	}

	machine := &RemoteMachine{
		Host:         "remote.example.com",
		WGAssignedIP: "10.225.1.5",
	}

	envs := []cilod.Environment{
		{
			Name:     "remote-env",
			Services: []string{"api", "db", "redis"},
			Subnet:   "10.224.5.0/24",
		},
	}

	if err := AddRemoteMachine(machine, envs); err != nil {
		t.Fatalf("AddRemoteMachine failed: %v", err)
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}
	config := string(data)

	if !strings.Contains(config, "# Remote machine: remote.example.com") {
		t.Errorf("Expected remote machine header, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/api.remote-env.test/10.225.1.5") {
		t.Errorf("Expected api.remote-env.test entry, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/db.remote-env.test/10.225.1.5") {
		t.Errorf("Expected db.remote-env.test entry, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/redis.remote-env.test/10.225.1.5") {
		t.Errorf("Expected redis.remote-env.test entry, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/api.local-env.test/10.224.1.2") {
		t.Errorf("Local entries should be preserved, got:\n%s", config)
	}
}

func TestRemoveRemoteDNSEntries(t *testing.T) {
	dnsDir := t.TempDir()
	origGetDNSDir := getDNSDir
	getDNSDir = func() string { return dnsDir }
	defer func() { getDNSDir = origGetDNSDir }()

	initialConfig := `# Auto-generated by cilo
port=5354
bind-interfaces
listen-address=127.0.0.1

# Environment: local-env
address=/api.local-env.test/10.224.1.2

# Remote machine: remote.example.com
address=/api.remote-env.test/10.225.1.5
address=/db.remote-env.test/10.225.1.5
# End remote machine: remote.example.com

# Environment: another-local
address=/web.other.test/10.224.2.2

`
	configPath := filepath.Join(dnsDir, "dnsmasq.conf")
	if err := os.WriteFile(configPath, []byte(initialConfig), 0644); err != nil {
		t.Fatalf("Failed to write initial config: %v", err)
	}

	if err := RemoveRemoteMachine("remote.example.com"); err != nil {
		t.Fatalf("RemoveRemoteMachine failed: %v", err)
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}
	config := string(data)

	if strings.Contains(config, "# Remote machine: remote.example.com") {
		t.Errorf("Remote machine header should be removed, got:\n%s", config)
	}

	if strings.Contains(config, "address=/api.remote-env.test/10.225.1.5") {
		t.Errorf("Remote api entry should be removed, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/api.local-env.test/10.224.1.2") {
		t.Errorf("Local entries should be preserved, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/web.other.test/10.224.2.2") {
		t.Errorf("Other local entries should be preserved, got:\n%s", config)
	}
}

func TestRemoteDNSResolution(t *testing.T) {
	dnsDir := t.TempDir()
	origGetDNSDir := getDNSDir
	getDNSDir = func() string { return dnsDir }
	defer func() { getDNSDir = origGetDNSDir }()

	machine := &RemoteMachine{
		Host:         "remote.example.com",
		WGAssignedIP: "10.225.1.5",
	}

	envs := []cilod.Environment{
		{
			Name:     "remote-env",
			Services: []string{"api", "db"},
			Subnet:   "10.224.5.0/24",
		},
	}

	if err := AddRemoteMachine(machine, envs); err != nil {
		t.Fatalf("AddRemoteMachine failed: %v", err)
	}

	configPath := filepath.Join(dnsDir, "dnsmasq.conf")
	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}
	config := string(data)

	if !strings.Contains(config, "address=/api.remote-env.test/10.225.1.5") {
		t.Errorf("Expected api.remote-env.test to resolve to WG IP 10.225.1.5, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/db.remote-env.test/10.225.1.5") {
		t.Errorf("Expected db.remote-env.test to resolve to WG IP 10.225.1.5, got:\n%s", config)
	}

	expectedEntries := []string{
		"address=/api.remote-env.test/",
		"address=/db.remote-env.test/",
	}

	for _, entry := range expectedEntries {
		if !strings.Contains(config, entry) {
			t.Errorf("Expected entry %s not found in config:\n%s", entry, config)
		}
	}
}

func TestUpdateRemoteDNSEntries(t *testing.T) {
	dnsDir := t.TempDir()
	origGetDNSDir := getDNSDir
	getDNSDir = func() string { return dnsDir }
	defer func() { getDNSDir = origGetDNSDir }()

	initialConfig := `# Auto-generated by cilo
port=5354
bind-interfaces
listen-address=127.0.0.1

# Remote machine: remote.example.com
address=/api.old-env.test/10.225.1.5
address=/db.old-env.test/10.225.1.5
# End remote machine: remote.example.com

`
	configPath := filepath.Join(dnsDir, "dnsmasq.conf")
	if err := os.WriteFile(configPath, []byte(initialConfig), 0644); err != nil {
		t.Fatalf("Failed to write initial config: %v", err)
	}

	machine := &RemoteMachine{
		Host:         "remote.example.com",
		WGAssignedIP: "10.225.1.5",
	}

	envs := []cilod.Environment{
		{
			Name:     "new-env",
			Services: []string{"api", "cache"},
			Subnet:   "10.224.6.0/24",
		},
	}

	if err := UpdateRemoteDNSEntries(machine, envs); err != nil {
		t.Fatalf("UpdateRemoteDNSEntries failed: %v", err)
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}
	config := string(data)

	if strings.Contains(config, "address=/api.old-env.test/") {
		t.Errorf("Old api entry should be removed, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/api.new-env.test/10.225.1.5") {
		t.Errorf("Expected new api entry, got:\n%s", config)
	}

	if !strings.Contains(config, "address=/cache.new-env.test/10.225.1.5") {
		t.Errorf("Expected cache entry, got:\n%s", config)
	}
}

func TestAddRemoteMachine_MultipleEnvironments(t *testing.T) {
	dnsDir := t.TempDir()
	origGetDNSDir := getDNSDir
	getDNSDir = func() string { return dnsDir }
	defer func() { getDNSDir = origGetDNSDir }()

	configPath := filepath.Join(dnsDir, "dnsmasq.conf")
	if err := os.WriteFile(configPath, []byte("# Initial config\n"), 0644); err != nil {
		t.Fatalf("Failed to write initial config: %v", err)
	}

	machine := &RemoteMachine{
		Host:         "remote.example.com",
		WGAssignedIP: "10.225.1.5",
	}

	envs := []cilod.Environment{
		{
			Name:     "env1",
			Services: []string{"api"},
			Subnet:   "10.224.5.0/24",
		},
		{
			Name:     "env2",
			Services: []string{"web", "db"},
			Subnet:   "10.224.6.0/24",
		},
	}

	if err := AddRemoteMachine(machine, envs); err != nil {
		t.Fatalf("AddRemoteMachine failed: %v", err)
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}
	config := string(data)

	expectedEntries := []string{
		"address=/api.env1.test/10.225.1.5",
		"address=/web.env2.test/10.225.1.5",
		"address=/db.env2.test/10.225.1.5",
	}

	for _, entry := range expectedEntries {
		if !strings.Contains(config, entry) {
			t.Errorf("Expected entry %s not found in config:\n%s", entry, config)
		}
	}
}

func TestLocalDNSEntriesUnaffected(t *testing.T) {
	dnsDir := t.TempDir()
	origGetDNSDir := getDNSDir
	getDNSDir = func() string { return dnsDir }
	defer func() { getDNSDir = origGetDNSDir }()

	initialConfig := `# Auto-generated by cilo
port=5354
bind-interfaces
listen-address=127.0.0.1

# Host: local
# Environment: myproject-dev
address=/api.myproject-dev.test/10.224.1.2
address=/db.myproject-dev.test/10.224.1.3
address=/.myproject.myproject-dev.test/10.224.1.2
address=/myproject.myproject-dev.test/10.224.1.2

# Environment: myproject-test
address=/api.myproject-test.test/10.224.2.2

`
	configPath := filepath.Join(dnsDir, "dnsmasq.conf")
	if err := os.WriteFile(configPath, []byte(initialConfig), 0644); err != nil {
		t.Fatalf("Failed to write initial config: %v", err)
	}

	machine := &RemoteMachine{
		Host:         "remote.example.com",
		WGAssignedIP: "10.225.1.5",
	}

	envs := []cilod.Environment{
		{
			Name:     "remote-env",
			Services: []string{"api"},
			Subnet:   "10.224.5.0/24",
		},
	}

	if err := AddRemoteMachine(machine, envs); err != nil {
		t.Fatalf("AddRemoteMachine failed: %v", err)
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		t.Fatalf("Failed to read config: %v", err)
	}
	config := string(data)

	localEntries := []string{
		"address=/api.myproject-dev.test/10.224.1.2",
		"address=/db.myproject-dev.test/10.224.1.3",
		"address=/.myproject.myproject-dev.test/10.224.1.2",
		"address=/myproject.myproject-dev.test/10.224.1.2",
		"address=/api.myproject-test.test/10.224.2.2",
	}

	for _, entry := range localEntries {
		if !strings.Contains(config, entry) {
			t.Errorf("Local entry %s should be preserved, got:\n%s", entry, config)
		}
	}

	if !strings.Contains(config, "address=/api.remote-env.test/10.225.1.5") {
		t.Errorf("Remote entry should be present, got:\n%s", config)
	}
}
