# Cilo Architecture Design

**Version:** 2.0 (Post-Epic)  
**Last Updated:** 2026-02-03

---

## Core Concepts

### Environment
An **environment** is an isolated, runnable copy of a Compose project with:
- Its own workspace filesystem
- Its own Docker network (unique subnet)
- Its own DNS namespace
- Its own set of running containers

**Key Properties:**
- **Name:** Unique within a project (e.g., `dev`, `staging`, `feature-x`)
- **Project:** Logical grouping (e.g., `myapp`)
- **Host:** Where it runs (local or remote)
- **Runtime:** Docker, Podman, etc.
- **State:** created, running, stopped, error

### Project
A **project** is a source of truth for one or more environments:
- Source directory containing `docker-compose.yml`
- Shared configuration (`.cilo/config.yml`)
- Base for creating environments

**Relationship:** 1 project → N environments

### Host
A **host** is where environments run:
- **Local:** Current machine
- **Remote:** Accessed via SSH, Tailscale, WireGuard, etc.

**Properties:**
- Unique ID (e.g., `local`, `prod-server`, `agent-host-01`)
- Connection method (local, ssh, tailscale, etc.)
- Runtime provider (Docker, Podman)

### Workspace
A **workspace** is the filesystem location for an environment:
- **Local:** `~/.cilo/envs/<project>/<env>/`
- **Remote:** `~/.cilo/envs/<project>/<env>/` on remote host

**Contains:**
- `docker-compose.yml` (copied from project, user-editable)
- `.env` (environment variables)
- `.cilo/override.yml` (generated by cilo)
- `.cilo/meta.json` (environment metadata)
- Any copied project files

---

## System Architecture

### High-Level Layers

```
┌─────────────────────────────────────────────────────┐
│                  CLI Layer                          │
│  (cobra commands: create, up, down, destroy, etc.) │
└────────────────────┬────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────┐
│                 Core Layer                          │
│  - State management (global + per-host)            │
│  - DNS management (rendering, reconciliation)      │
│  - Workspace management (copy, sync, cleanup)      │
│  - Lifecycle orchestration                         │
└────────────────────┬────────────────────────────────┘
                     │
        ┌────────────┴────────────┬──────────────────┐
        │                         │                  │
┌───────▼──────────┐   ┌──────────▼────────┐  ┌──────▼──────┐
│ Runtime Provider │   │  Mesh Provider    │  │ DNS Provider│
│   (Docker,       │   │  (Tailscale,      │  │ (dnsmasq,   │
│    Podman)       │   │   WireGuard, SSH) │  │  CoreDNS)   │
└───────┬──────────┘   └──────────┬────────┘  └──────┬──────┘
        │                         │                  │
┌───────▼─────────────────────────▼──────────────────▼──────┐
│              External Systems                             │
│  - Docker daemon                                          │
│  - Tailscale daemon                                       │
│  - System DNS resolver (systemd-resolved, macOS resolver)│
└───────────────────────────────────────────────────────────┘
```

---

## Component Design

### 1. State Management

#### State Schema v2
```json
{
  "version": 2,
  "subnet_counter": 42,
  "hosts": {
    "local": {
      "provider": "docker",
      "environments": {
        "myapp/dev": { ... },
        "myapp/staging": { ... }
      }
    },
    "prod-server": {
      "provider": "docker",
      "mesh_provider": "tailscale",
      "mesh_id": "myserver.tail123.ts.net",
      "environments": {
        "api/prod": { ... }
      }
    }
  },
  "shared_networks": {
    "cilo-shared-db": {
      "created_by": "myapp/dev",
      "created_at": "2026-01-15T10:30:00Z",
      "referenced_by": ["myapp/dev", "myapp/staging", "frontend/dev"]
    }
  }
}
```

#### Environment Object
```json
{
  "name": "dev",
  "project": "myapp",
  "created_at": "2026-01-15T10:30:00Z",
  "subnet": "10.224.1.0/24",
  "status": "running",
  "source": "/home/user/projects/myapp",
  "runtime_provider": "docker",
  "shared_networks": ["cilo-shared-db"],
  "services": {
    "nginx": {
      "name": "nginx",
      "ip": "10.224.1.2",
      "container": "cilo_dev_nginx",
      "url": "http://nginx.dev.test",
      "is_ingress": true,
      "hostnames": ["api", "admin", "cpanel"]
    },
    "postgres": {
      "name": "postgres",
      "ip": "10.224.1.3",
      "container": "cilo_dev_postgres",
      "is_ingress": false,
      "hostnames": []
    }
  }
}
```

#### State Operations (Thread-Safe)

**File Locking Strategy:**
```go
type StateFile struct {
    path string
    lock *flock.Flock  // File-based lock
}

func (s *StateFile) WithLock(fn func(*State) error) error {
    // Acquire exclusive lock
    if err := s.lock.Lock(); err != nil {
        return err
    }
    defer s.lock.Unlock()
    
    // Read current state
    state, err := s.read()
    if err != nil {
        return err
    }
    
    // Apply mutation
    if err := fn(state); err != nil {
        return err
    }
    
    // Atomic write (temp + rename)
    return s.atomicWrite(state)
}
```

**Atomic Write:**
```go
func (s *StateFile) atomicWrite(state *State) error {
    data, _ := json.MarshalIndent(state, "", "  ")
    
    // Write to temp file
    tmpPath := s.path + ".tmp"
    if err := os.WriteFile(tmpPath, data, 0644); err != nil {
        return err
    }
    
    // Atomic rename
    return os.Rename(tmpPath, s.path)
}
```

**Schema Migrations:**
```go
type Migration interface {
    Version() int
    Migrate(*State) error
}

var migrations = []Migration{
    &MigrateV1ToV2{},  // Add hosts object, move envs
    &MigrateV2ToV3{},  // Add users, quotas (future)
}

func ApplyMigrations(state *State) error {
    for _, m := range migrations {
        if state.Version < m.Version() {
            if err := m.Migrate(state); err != nil {
                return err
            }
            state.Version = m.Version()
        }
    }
    return nil
}
```

---

### 2. Runtime Provider Interface

**Core Abstraction:**
```go
package runtime

type Provider interface {
    // Lifecycle operations
    Create(ctx context.Context, env *Environment, opts CreateOptions) error
    Up(ctx context.Context, env *Environment, opts UpOptions) error
    Down(ctx context.Context, env *Environment) error
    Destroy(ctx context.Context, env *Environment) error
    
    // Introspection - reconciliation source of truth
    Status(ctx context.Context, env *Environment) (*Status, error)
    Services(ctx context.Context, env *Environment) ([]*Service, error)
    Logs(ctx context.Context, env *Environment, service string, opts LogOptions) (io.ReadCloser, error)
    
    // Execution
    Exec(ctx context.Context, env *Environment, service, command string, opts ExecOptions) error
    
    // Network management
    AllocateNetwork(ctx context.Context, subnet string) (*Network, error)
    ReleaseNetwork(ctx context.Context, network *Network) error
    JoinExternalNetwork(ctx context.Context, env *Environment, networkName string) error
    
    // Validation
    Validate(ctx context.Context, composePath string) error
}

// Shared types
type Status struct {
    State       EnvironmentState  // created, running, stopped, error
    Services    []*Service
    LastUpdated time.Time
}

type UpOptions struct {
    Build    bool
    Recreate bool
}

type CreateOptions struct {
    Source         string
    SharedNetworks []string
    CopyFiles      bool
}
```

**Why This Interface:**
- **Minimal surface area:** Only operations that vary by runtime
- **Reconciliation-friendly:** `Services()` provides source of truth
- **Testable:** Easy to mock for tests
- **Extensible:** New providers just implement this

**Docker Implementation:**
```go
type DockerProvider struct {
    host *Host  // nil = local, set = remote
}

func (p *DockerProvider) Up(ctx, env, opts) error {
    workspace := getWorkspace(env)
    overridePath := filepath.Join(workspace, ".cilo/override.yml")
    
    cmd := []string{
        "docker", "compose",
        "-f", filepath.Join(workspace, "docker-compose.yml"),
        "-f", overridePath,
        "-p", fmt.Sprintf("cilo_%s", env.Name),
    }
    
    if opts.Build {
        cmd = append(cmd, "--build")
    }
    
    cmd = append(cmd, "up", "-d")
    
    if p.host != nil {
        // Remote execution via SSH or Docker context
        return p.remoteExec(ctx, cmd)
    }
    
    return exec.CommandContext(ctx, cmd[0], cmd[1:]...).Run()
}
```

**Podman Implementation:**
```go
type PodmanProvider struct {
    host *Host
}

func (p *PodmanProvider) Up(ctx, env, opts) error {
    // 95% same as Docker, just s/docker/podman/
    // Podman compose has slight differences in flags
    
    cmd := []string{
        "podman", "compose",
        "-f", filepath.Join(workspace, "docker-compose.yml"),
        "-f", overridePath,
        // ... rest is identical
    }
}
```

---

### 3. Compose Transformation (Override Model)

**Old Approach (Deep Rewrite):**
```yaml
# PROBLEMS:
# - Modifies user's structure
# - Breaks extends, profiles, anchors
# - Volume path rewriting fragile
# - Hard to debug differences

services:
  nginx:
    image: nginx
    ports: []  # REMOVED
    container_name: cilo_dev_nginx  # INJECTED
    volumes:
      - ../data:/data  # REWRITTEN
    networks:
      default:
        ipv4_address: 10.224.1.2  # INJECTED
```

**New Approach (Minimal Override):**

**Original `docker-compose.yml` (UNTOUCHED):**
```yaml
services:
  nginx:
    image: nginx
    ports:
      - "80:80"
    volumes:
      - ./data:/data
  postgres:
    image: postgres:15
```

**Generated `.cilo/override.yml`:**
```yaml
# Auto-generated by cilo
# This file adds cilo-specific networking and configuration

services:
  nginx:
    container_name: cilo_dev_nginx
    ports: []  # Override to disable port publishing
    networks:
      cilo-dev:
        ipv4_address: 10.224.1.2
    labels:
      cilo.environment: "dev"
      cilo.project: "myapp"
      
  postgres:
    container_name: cilo_dev_postgres
    ports: []
    networks:
      cilo-dev:
        ipv4_address: 10.224.1.3

networks:
  cilo-dev:
    name: cilo-dev
    driver: bridge
    ipam:
      config:
        - subnet: 10.224.1.0/24
```

**Running:**
```bash
docker compose \
  -f docker-compose.yml \
  -f .cilo/override.yml \
  -p cilo_dev \
  up -d
```

**Benefits:**
- User's compose file never modified
- Works with extends, profiles, multiple files
- Volume paths stay relative to user's compose file
- Clear separation: user config vs cilo config
- Diffs are minimal and obvious

---

### 4. DNS Architecture

#### DNS Generation (Rendered from State)

**Old Approach (Text Editing):**
```
# PROBLEMS:
# - In-place editing fragile
# - Marker-based removal error-prone
# - Hard to ensure consistency
# - Not atomic
```

**New Approach (Full Render):**
```go
func RenderDNSConfig(state *State) (string, error) {
    var config strings.Builder
    
    // Header
    config.WriteString("# Auto-generated by cilo\n")
    config.WriteString("# DO NOT EDIT MANUALLY\n\n")
    config.WriteString(baseConfig())  // Port, listen-address, etc.
    config.WriteString("\n")
    
    // For each host
    for hostID, host := range state.Hosts {
        // Get host IP (local = 127.0.0.1, remote = mesh IP)
        hostIP := getHostIP(host)
        
        // For each environment on this host
        for envKey, env := range host.Environments {
            // Service-based DNS: service.env.test
            for _, svc := range env.Services {
                config.WriteString(fmt.Sprintf(
                    "address=/%s.%s.test/%s\n",
                    svc.Name, env.Name, svc.IP,
                ))
            }
            
            // Project-based wildcard (if project set)
            if env.Project != "" && hasIngressService(env) {
                ingress := getIngressService(env)
                config.WriteString(fmt.Sprintf(
                    "address=/.%s.%s.test/%s\n",
                    env.Project, env.Name, ingress.IP,
                ))
                config.WriteString(fmt.Sprintf(
                    "address=/%s.%s.test/%s\n",
                    env.Project, env.Name, ingress.IP,
                ))
            }
            
            // Custom hostnames
            for _, svc := range env.Services {
                for _, hostname := range svc.Hostnames {
                    config.WriteString(fmt.Sprintf(
                        "address=/%s.%s.test/%s\n",
                        hostname, env.Name, svc.IP,
                    ))
                }
            }
        }
    }
    
    return config.String(), nil
}
```

**Atomic Update:**
```go
func UpdateDNS(state *State) error {
    // Render full config
    config, err := RenderDNSConfig(state)
    if err != nil {
        return err
    }
    
    // Validate before writing
    if err := ValidateDNSConfig(config); err != nil {
        return err
    }
    
    configPath := getDNSConfigPath()
    
    // Atomic write (temp + rename)
    tmpPath := configPath + ".tmp"
    if err := os.WriteFile(tmpPath, []byte(config), 0644); err != nil {
        return err
    }
    
    if err := os.Rename(tmpPath, configPath); err != nil {
        return err
    }
    
    // Graceful reload
    return reloadDNSMasq()
}
```

#### Custom DNS Suffixes

By default, cilo uses `.test` as the TLD for all environment services. This is configurable per-project via the `dns_suffix` setting in `.cilo/config.yml`.

**Workflow:**
1.  **Project Level:** Set `dns_suffix: .localhost` in `config.yml`.
2.  **Environment Level:** During `cilo up`, the suffix is read and injected into the DNS rendering logic.
3.  **System Level:** The system resolver must be configured to forward the custom suffix to `127.0.0.1:5354`. This is handled by `cilo dns setup --dns-suffix .localhost`.

**The `.localhost` Conflict:**
Using `.localhost` as a suffix presents unique challenges:
- **Standard Behavior:** RFC 6761 specifies that `localhost` should resolve to `127.0.0.1`. Many browsers and OS resolvers hardcode this.
- **Cilo Behavior:** If cilo takes over `.localhost`, it will resolve subdomains (e.g., `api.dev.localhost`) to internal container IPs (e.g., `10.224.1.2`).
- **Conflict:** If a user is running a service directly on their host (e.g., `localhost:3000`) and tries to use `app.localhost` to point to it, cilo might intercept it if an environment is named `app`. 
- **Recommendation:** Use `.test` (RFC 6761 reserved for testing) to avoid conflicts with system defaults. Use `.localhost` only if you explicitly want to override local service discovery with cilo's container-based discovery.

#### DNS for Remote Environments

> **⚠️ DESIGN GATE:** This section describes ONE CANDIDATE routing model. The actual model must be chosen before implementation per [Phase 2B: Remote Operation](../phases/PHASE_2B_REMOTE_OPERATION.md). Do not implement this until the design gate is resolved.

**Local Environment:**
```
nginx.dev.test → 10.224.1.2 (local Docker network)
```

**Remote Environment (Candidate: Host-level routing via Tailscale):**
```
nginx.dev.prod.test → 100.64.1.5 (Tailscale IP of remote host)
                      └─ nginx container is on 10.224.5.2 on remote host
                         └─ Tailscale routes to remote host, host routes to container
```

**Alternative models to evaluate:**
1. Subnet routing over mesh (route Docker subnets directly)
2. Host-level proxy/ingress (terminate on host, forward to container)
3. Service mesh integration (Consul Connect, etc.)

See [Phase 2B](../phases/PHASE_2B_REMOTE_OPERATION.md) for design gate criteria.

---

### 5. Mesh Networking

> **⚠️ DESIGN GATE:** This section is speculative. Do not implement until [Phase 2B routing model decision](../phases/PHASE_2B_REMOTE_OPERATION.md) is made.

#### Mesh Provider Interface (Draft)
```go
package mesh

type Provider interface {
    // Get routable IP for a host
    HostIP(hostID string) (net.IP, error)
    
    // Connectivity check
    Ping(hostID string) error
    
    // Connection for file transfer, exec, etc.
    Connect(hostID string) (net.Conn, error)
}
```

#### Tailscale Provider (Draft - One Candidate)
```go
type TailscaleProvider struct{}

func (p *TailscaleProvider) HostIP(hostID string) (net.IP, error) {
    // Parse: myserver.tail123.ts.net → 100.64.1.5
    // Method 1: tailscale status --json
    // Method 2: DNS lookup of hostname.tailnet.ts.net
    
    cmd := exec.Command("tailscale", "status", "--json")
    output, err := cmd.Output()
    if err != nil {
        return nil, err
    }
    
    var status TailscaleStatus
    json.Unmarshal(output, &status)
    
    for _, peer := range status.Peers {
        if peer.HostName == hostID {
            return peer.TailscaleIPs[0], nil
        }
    }
    
    return nil, fmt.Errorf("host %s not found in tailscale network", hostID)
}
```

#### WireGuard Provider
```go
type WireGuardProvider struct {
    config *WireGuardConfig
}

func (p *WireGuardProvider) HostIP(hostID string) (net.IP, error) {
    // Look up in WireGuard config
    peer, ok := p.config.Peers[hostID]
    if !ok {
        return nil, fmt.Errorf("unknown peer: %s", hostID)
    }
    return peer.AllowedIPs[0], nil
}
```

#### SSH Provider (Fallback)
```go
type SSHProvider struct{}

func (p *SSHProvider) Connect(hostID string) (net.Conn, error) {
    // hostID is "user@hostname:port"
    config := &ssh.ClientConfig{...}
    return ssh.Dial("tcp", hostID, config)
}

func (p *SSHProvider) HostIP(hostID string) (net.IP, error) {
    // Parse hostname from user@hostname:port
    // Resolve via DNS
    host := parseHost(hostID)
    ips, err := net.LookupIP(host)
    return ips[0], err
}
```

---

### 6. Reconciliation System

**Purpose:** Sync state with runtime reality

**When to Reconcile:**
- On `cilo status <env>`
- On `cilo doctor`
- Before any operation (lazy reconciliation)
- After crashes (on next command)

**Process:**
```go
func ReconcileEnvironment(env *Environment, provider runtime.Provider) error {
    // Get actual state from runtime
    status, err := provider.Status(ctx, env)
    if err != nil {
        return err
    }
    
    services, err := provider.Services(ctx, env)
    if err != nil {
        return err
    }
    
    // Update environment state
    env.Status = status.State
    env.Services = make(map[string]*Service)
    for _, svc := range services {
        env.Services[svc.Name] = svc
    }
    
    // Persist
    return state.UpdateEnvironment(env)
}
```

**Reconcile All (Doctor):**
```go
func ReconcileAll(state *State) []error {
    var errors []error
    
    for hostID, host := range state.Hosts {
        provider := getProvider(host)
        
        for envKey, env := range host.Environments {
            if err := ReconcileEnvironment(env, provider); err != nil {
                errors = append(errors, fmt.Errorf("%s: %w", envKey, err))
            }
        }
    }
    
    // Also check for orphaned Docker networks
    orphanedNets := findOrphanedNetworks(state)
    for _, net := range orphanedNets {
        fmt.Printf("Warning: orphaned network %s\n", net)
    }
    
    return errors
}
```

---

## Data Flow Diagrams

### Create Environment Flow
```
User: cilo create dev --from ~/myapp

1. CLI Layer
   ├─ Parse arguments
   ├─ Validate project exists
   └─ Call core.CreateEnvironment()

2. Core Layer
   ├─ Allocate subnet (with collision check)
   ├─ Create workspace directory
   ├─ Copy project files
   ├─ Generate override.yml
   ├─ Update state (with lock)
   └─ Return environment

3. State persisted:
   ~/.cilo/state.json (atomic write)
   
4. Workspace created:
   ~/.cilo/envs/myapp/dev/
   ├─ docker-compose.yml (copied)
   ├─ .env
   └─ .cilo/
      ├─ override.yml (generated)
      └─ meta.json
```

### Up Environment Flow
```
User: cilo up dev

1. CLI Layer
   └─ Call core.UpEnvironment()

2. Core Layer
   ├─ Load environment from state
   ├─ Get runtime provider for host
   ├─ Call provider.Up()
   ├─ Reconcile (get actual service IPs)
   ├─ Update DNS config (render + atomic write)
   ├─ Reload DNS
   └─ Update state

3. Runtime Provider (Docker)
   ├─ docker compose -f compose.yml -f override.yml up -d
   ├─ Wait for containers to start
   ├─ Inspect containers for IPs
   └─ Return service list

4. DNS Updated:
   ~/.cilo/dns/dnsmasq.conf (full render)
   
5. State Updated:
   environment.status = "running"
   environment.services = [...reconciled...]
```

### Remote Create Flow
```
User: cilo create dev --from ~/myapp --remote prod

1. CLI Layer
   └─ Resolve remote host "prod"

2. Core Layer
   ├─ Get mesh provider for host
   ├─ Test connectivity (ping)
   ├─ Sync workspace to remote (rsync or git)
   ├─ Allocate subnet
   ├─ Generate override.yml (locally, then sync)
   └─ Call remote provider

3. Runtime Provider (Remote Docker)
   ├─ SSH to remote host
   ├─ Execute: docker compose up -d
   ├─ Get container IPs
   └─ Return services

4. DNS Updated (locally):
   nginx.dev.prod.test → 100.64.1.5 (Tailscale IP)
   
5. Mesh Provider routes:
   Local DNS → Tailscale → Remote Host → Docker Network → Container
```

---

## Security Considerations

### State File
- **Location:** `~/.cilo/state.json` (user-readable only: 0600)
- **Contents:** No secrets, only references to environments
- **Locking:** Prevents corruption, not auth

### DNS
- **Exposure:** Only `.test` TLD, not routable outside machine
- **dnsmasq:** Listens only on 127.0.0.1:5354
- **System resolver:** Points `.test` to localhost only

### Remote Hosts
- **Authentication:** Delegated to mesh provider (Tailscale ACLs, SSH keys, etc.)
- **Authorization:** Cilo trusts mesh connectivity = authorization
- **Future:** Phase 3 adds API tokens, per-user quotas

### Multi-User (Phase 3)
- **Isolation:** Users can only see/modify their own environments
- **Quotas:** Prevent resource exhaustion
- **Audit log:** Track who created/destroyed what

---

## Performance Characteristics

### State Operations
- **Read:** O(1) with file read (~1ms)
- **Write:** O(1) with lock contention (~10ms under contention)
- **Lock hold time:** <50ms (just mutation + write)

### DNS Updates
- **Render:** O(E*S) where E=environments, S=services per env (~100 envs = ~1ms)
- **Reload:** ~100-200ms (dnsmasq restart)
- **Resolution:** O(1) via dnsmasq hash table

### Reconciliation
- **Per environment:** O(S) where S=services (~5-10 services = ~100ms)
- **Full reconcile:** O(E*S) (~100 envs = ~10s)

### Remote Operations
- **Latency:** +RTT for each operation (SSH: ~20-50ms, Tailscale: ~10-30ms)
- **Workspace sync:** Depends on project size (rsync of 100MB = ~5-10s)

---

## Extensibility Points

### Custom Providers
```go
// New runtime provider (e.g., Kubernetes)
type KubernetesProvider struct {
    client *kubernetes.Clientset
}

func (p *KubernetesProvider) Up(ctx, env, opts) error {
    // Convert compose to k8s manifests
    // Create namespace = environment
    // Apply manifests
}
```

### Custom DNS Backends
```go
// Interface allows swapping dnsmasq for CoreDNS, etc.
type DNSBackend interface {
    RenderConfig(state *State) (string, error)
    Reload() error
}
```

### Plugins (Future)
```go
// Plugin system for custom transformations, hooks, etc.
type Plugin interface {
    Name() string
    BeforeUp(env *Environment) error
    AfterUp(env *Environment) error
}
```

---

## Testing Strategy

### Unit Tests
- State operations (locking, atomicity, migrations)
- DNS rendering (various environment configurations)
- Compose override generation
- Subnet allocation

### Integration Tests
- Full create/up/down/destroy cycle
- DNS resolution end-to-end
- Concurrent creates (race detection)
- Crash recovery (kill mid-operation)
- Remote operation (requires test harness)

### Test Harness
```bash
# Run integration tests in isolated environment
make test-integration

# Spins up:
# - Temporary state file
# - Temporary DNS config
# - Test Docker network ranges
# - Mock remote hosts (via SSH to localhost)
```

---

## Deployment Model

### Single Binary
```bash
go build -o cilo main.go

# Binary includes:
# - CLI commands
# - All providers (Docker, Podman compiled-in)
# - All mesh providers (Tailscale, WireGuard, SSH)
```

### Installation
```bash
# Download binary
curl -L https://github.com/cilo/cilo/releases/latest/download/cilo-linux-amd64 -o cilo
chmod +x cilo
sudo mv cilo /usr/local/bin/

# Initialize
sudo cilo init
```

### Updates
```bash
cilo update
# OR
brew upgrade cilo
apt-get update && apt-get upgrade cilo
```

---

## Backwards Compatibility

### Version Detection
```go
func LoadState() (*State, error) {
    data, _ := os.ReadFile(statePath)
    
    var versionCheck struct {
        Version int `json:"version"`
    }
    json.Unmarshal(data, &versionCheck)
    
    switch versionCheck.Version {
    case 0, 1:
        return migrateV1ToV2(data)
    case 2:
        return parseV2(data)
    default:
        return nil, fmt.Errorf("unsupported state version: %d", versionCheck.Version)
    }
}
```

### Migration Path
- Phase 1: State v1 → v2 (automatic, one-way)
- Phase 3: State v2 → v3 (automatic, adds users/quotas)
- Always forward-compatible (new fields ignored by old versions)

---

## Related Specs

- [Provider Interface Spec](../specs/PROVIDER_INTERFACE_SPEC.md)
- [Mesh Networking Spec](../specs/MESH_NETWORKING_SPEC.md)
- [State Schema](../specs/STATE_SCHEMA.md)
- [DNS Architecture](../specs/DNS_ARCHITECTURE.md)
